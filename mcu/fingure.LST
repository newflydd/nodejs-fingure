C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 10:15:35 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE FINGURE
OBJECT MODULE PLACED IN fingure.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE fingure.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2           * @CreateTime: Mar 3, 2017 4:25 PM 
   3           * @Author: Smith Ding 
   4           * @Contact: newflydd@gmail.com 
   5           * @Last Modified By: Smith Ding
   6           * @Last Modified Time: Mar 3, 2017 4:46 PM
   7           * @Description: æœ¬è½¯ä»¶ç”¨æ¥å°†é¢æ¿ä¸æŒ‡çº¹æ¨¡å—è¿›è¡Œé€šä¿¡
   8           * @Company: JIANGSU SAIYANG MECHANICAL & ELECTRICAL TECHNOLOGY CO.,LTD
   9           */
  10          
  11          #include <reg52.h>
  12          #include <intrins.h>
  13          #include "uart.h"
  14          #include "fingure.h"
  15          #include "event.h"
  16          
  17          void delay(uint num){
  18   1          while(num--);
  19   1      }
  20          
  21          //å¯åŠ¨åˆå§‹åŒ–
  22          void initMain(){
  23   1          //åˆå§‹åŒ–å‘é€æŒ‡ä»¤å‰7ä¸ªbyte
  24   1          for(ucharTemp = 0; ucharTemp < 7; ucharTemp ++){
  25   2              sendBuffer[ucharTemp] = sendPackageHeader[ucharTemp];
  26   2          }
  27   1      
  28   1          //å°†ä¸²å£æ¥å—å¯„å­˜å™¨çš„æ•°æ®é•¿åº¦ç½®0
  29   1          receiveBufferLength = 0;
  30   1          
  31   1          //æ¥å—åˆ°äº†ä¸²å£é€šçŸ¥å¼€å…³ç½®0
  32   1          receiveCmdNotify = 0;
  33   1          //ç­‰å¾…ä¸²å£æ¶ˆæ¯å¼€å…³ç½®0
  34   1          waitForReceive = 0;
  35   1      
  36   1          EA = 1;     //æ€»ä¸­æ–­å¼€å…³æ‰“å¼€
  37   1      }
  38          
  39          void main(){    
  40   1          uchar fingureReadable = 1;      //ä¸‹ä½æœºæŒ‡çº¹æ¨¡å—è¿æ¥æ€§ï¼Œ0æ—¶ä»£è¡¨å¯å‡†ç¡®è¿æ¥
  41   1          P1 = 0x3F;                      //@TODO:ä¸´æ—¶å°†æ•°ç ç®¡ç½®0
  42   1          delay(65535);
  43   1          delay(65535);
  44   1          delay(65535);
  45   1          delay(65535);
  46   1          delay(65535);
  47   1          delay(65535);
  48   1          delay(65535);
  49   1          delay(65535);
  50   1      
  51   1      initPrograme:
  52   1          initUart();
  53   1          initMain();
  54   1      
  55   1          fingureReadable = getAddressListFunction();
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 10:15:35 PAGE 2   

  56   1      
  57   1          if(fingureReadable){
  58   2              //@TODO: å¼‚å¸¸è­¦æŠ¥
  59   2              //P1 = display_code[fingureReadable];
  60   2              showWarning();
  61   2              goto initPrograme;
  62   2          }else{
  63   2              //P1 = 0x40;
  64   2          }
  65   1      
  66   1          //åˆå§‹åŒ–æŒ‡ä»¤ä¸º:0x11ï¼Œå‘æŒ‡çº¹æ¨¡å—å‘é€é‡‡é›†æŒ‡çº¹ç”¨æ¥éªŒè¯çš„å‘½ä»¤
  67   1          sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
  68   1      
  69   1          while(1){
  70   2              /* ä¸»å¾ªç¯ä¸­é¦–å…ˆåˆ¤æ–­æ˜¯å¦æœ‰ä¸²å£å“åº”ï¼Œå¦‚æœæœ‰ï¼Œåˆ™æœ¬æ¬¡å¾ªç¯ç”¨æ¥å¤„ç†æ¶ˆæ¯å“
             -åº” */
  71   2              if(receiveCmdNotify == 1){
  72   3                  receiveCmdNotify = 0;
  73   3      
  74   3                  receiveEventFunction();     //æ¥ä½æ¶ˆæ¯
  75   3      
  76   3                  continue;
  77   3              }
  78   2      
  79   2              /*
  80   2               * å¦‚æœæ²¡æœ‰ä¸²å£å“åº”
  81   2               * é¦–å…ˆåˆ¤æ–­æ˜¯å¦åœ¨ç­‰å¾…ä¸‹ä½æœºåé¦ˆï¼Œå¦‚æœåœ¨ç­‰å¾…ï¼Œå°±å¼€å§‹å»¶æ—¶è®¡æ•°
  82   2               */   
  83   2              if(waitForReceive == 1){
  84   3                  waitForReceive = 0;
  85   3                  if(waitTimes < 3)
  86   3                      waitForReceiveFunction();
  87   3                  else
  88   3                      resetFingureFunction();
  89   3                  continue;
  90   3              }
  91   2      
  92   2              /* 
  93   2               * ç»§ç»­åˆ¤æ–­P2å£æœ‰æ²¡æœ‰å½•å…¥é€šçŸ¥
  94   2               * å¦‚æœæœ‰å½•å…¥é€šçŸ¥ï¼Œå¹¶ä¸”å½“å‰çŠ¶æ€ä¸ºéªŒè¯çŠ¶æ€ï¼Œåˆ™å‘é€å½•å…¥å‘½ä»¤
  95   2               * å¦‚æœæ²¡æœ‰å½•å…¥é€šçŸ¥ï¼Œåˆ™å‘é€éªŒè¯å‘½ä»¤
  96   2               */
  97   2              inputSignal = checkInputSignal();
  98   2              if((sendCmdStatus ==  ACTION_GET_IMAGE_FOR_CHECK) && inputSignal){
  99   3                  sendCmdStatus = ACTION_GET_IMAGE_FOR_INPUT1;
 100   3              }
 101   2      
 102   2              //uartSendByte(sendCmdStatus);
 103   2      
 104   2              if(receiveCmdNotify == 0)
 105   2                  sendCmdFunction();
 106   2              delay(2000);
 107   2          }
 108   1      }
 109          
 110          /**
 111           * ä¸²å£ä¸­æ–­å‡½æ•°ï¼Œç”¨æ¥æ¥æ”¶ä¸‹ä½æœºæ•°æ®
 112           */
 113          void serialInterruptCallback() interrupt 4 {
 114   1        if(RI){       //æœ¬æ¬¡ä¸­æ–­æ˜¯æ¥å—ä¸­æ–­
 115   2          RI = 0;     //æ¥å—å®Œäº†æ¸…é›¶
 116   2      
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 10:15:35 PAGE 3   

 117   2              //å°†æ¥å—åˆ°çš„å­—èŠ‚è¿½åŠ åˆ°æŒ‡ä»¤æ¥å—ç¼“å†²åŒº
 118   2          receiveByte = SBUF;
 119   2          receiveBuffer[receiveBufferLength] = receiveByte;
 120   2              receiveBufferLength++;
 121   2      
 122   2              if(receiveBufferLength == 1 && receiveByte!=0xEF){
 123   3                  receiveBufferLength = 0;
 124   3                  return;
 125   3              }
 126   2      
 127   2              if(receiveBufferLength == 2 && receiveByte!=0x01){
 128   3                  receiveBufferLength = 0;
 129   3                  return;
 130   3              }
 131   2      
 132   2              if(receiveBufferLength == 3 && receiveByte!=0xFF){
 133   3                  receiveBufferLength = 0;
 134   3                  return;
 135   3              }
 136   2      
 137   2              if(receiveBufferLength == 4 && receiveByte!=0xFF){
 138   3                  receiveBufferLength = 0;
 139   3                  return;
 140   3              }
 141   2      
 142   2              if(receiveBufferLength == 5 && receiveByte!=0xFF){
 143   3                  receiveBufferLength = 0;
 144   3                  return;
 145   3              }
 146   2      
 147   2              if(receiveBufferLength == 6 && receiveByte!=0xFF){
 148   3                  receiveBufferLength = 0;
 149   3                  return;
 150   3              }
 151   2      
 152   2              if(receiveBufferLength == 9){
 153   3                  //å¦‚æœæŒ‡ä»¤æ¥å—åˆ°9ä¸ªbyteï¼Œè¿™æ—¶å€™åŒ…é•¿åº¦ä¿¡æ¯æœ‰äº†
 154   3                  receivePackageLength = (receiveBuffer[7] << 8) + receiveBuffer[8];
 155   3              }else if (receiveBufferLength == 9 + receivePackageLength) {
 156   3                  //ç»“æŸä¸€è½®æ¶ˆæ¯æ¥å—ï¼Œæ¸…ç©ºbufferï¼Œè§£æå‘½ä»¤
 157   3                  
 158   3                  //è·å–æ ¡éªŒå’Œ
 159   3                  receiveCheckSum = (receiveBuffer[7 + receivePackageLength] << 8) + receiveBuffer[8 + receivePa
             -ckageLength];
 160   3                  //è·å–ç¡®è®¤ç 
 161   3                  cfmCode = receiveBuffer[9];
 162   3                  //è·å–å‚æ•°
 163   3                  for (ucit = 0; ucit < receivePackageLength - 3; ucit++) {
 164   4                      receiveParams[ucit] = receiveBuffer[10 + ucit];
 165   4                  }
 166   3      
 167   3                  //éªŒè¯æ ¡éªŒå’Œ
 168   3                  uiit = 0;
 169   3                  for (ucit = 6; ucit < receiveBufferLength - 2; ucit++) {
 170   4                      uiit += receiveBuffer[ucit];
 171   4                  }
 172   3      
 173   3                  if (uiit == receiveCheckSum) {
 174   4                      //æ ¡éªŒæ­£ç¡®ï¼Œå‘å°„æ¶ˆæ¯å“åº”
 175   4                      receiveCmdNotify = 1;
 176   4                      receiveEventStatus = sendCmdStatus - 100;    //äº‹ä»¶ç±»å‹æ ¹æ®å‘é€ç±»å‹å¯¹åº”
 177   4                      waitForReceive = 0;                          //è§£é™¤ç­‰å¾…é”
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 10:15:35 PAGE 4   

 178   4                      waitTimes = 0;                               //ç­‰å¾…å“åº”æ¬¡æ•°å¤ä½
 179   4                  }
 180   3                  //æ¸…ç©ºæŒ‡ä»¤buffer
 181   3                  receiveBufferLength = 0;
 182   3              }            
 183   2        }
 184   1      }
 185          
 186          /**
 187           * ç»™sendBufferå˜é‡æ„å»ºå‘é€æŒ‡ä»¤
 188           * å‘½ä»¤å’Œå‚æ•°æ¥è‡ªäºå…¨å±€å˜é‡sendCmdAndParams
 189           * @param capLength [å‘½ä»¤+å‚æ•°çš„é•¿åº¦]
 190           */
 191          void buildSendCmd(uchar capLength){
 192   1          uint checkSum;
 193   1          uchar packageLength = capLength + 2;    //åŒ…é•¿åº¦ = æŒ‡ä»¤é›†é•¿åº¦ + æ ¡éªŒå’Œé•¿åº¦
 194   1          sendBufferLength = 11 + capLength;      // 7 + 2 + capLength + 2
 195   1      
 196   1          sendBuffer[7] = 0;                      //åŒ…é•¿åº¦é«˜ä½ä¸º0x00
 197   1          sendBuffer[8] = packageLength;          //åŒ…é•¿åº¦ä½ä½ä¸ºå®é™…åŒ…é•¿åº¦
 198   1          
 199   1          //æ„å»ºå‘é€æŒ‡ä»¤ä¸²å£æ¶ˆæ¯ä¸­çš„æŒ‡ä»¤å’Œå‚æ•°
 200   1          for(ucharTemp = 0; ucharTemp < capLength; ucharTemp++){
 201   2              sendBuffer[9+ucharTemp] = sendCmdAndParams[ucharTemp];
 202   2          }
 203   1      
 204   1          checkSum = getCheckSum(packageLength, sendCmdAndParams, capLength);
 205   1          sendBuffer[9 + capLength]  = checkSum>>8;
 206   1          sendBuffer[10 + capLength] = checkSum;
 207   1      }
 208          
 209          /**
 210           * [è®¡ç®—æ ¡éªŒå’Œ]
 211           * @param  packageLength [åŒ…é•¿åº¦]
 212           * @param  cmdAndParams  [å‘½ä»¤å’Œå‚æ•°æ•°ç»„]
 213           * @param  capLength     [å‘½ä»¤å’Œå‚æ•°é•¿åº¦]
 214           * @return               [2byte æ ¡éªŒå’Œ]
 215           */
 216          uint getCheckSum(uchar packageLength, uchar* cmdAndParams, uchar capLength){
 217   1          uintTemp = packageLength;
 218   1          for(ucharTemp = 0; ucharTemp < capLength; ucharTemp++){
 219   2              uintTemp += cmdAndParams[ucharTemp];
 220   2          }
 221   1          return uintTemp + 1;
 222   1      }
 223          
 224          /**
 225           * æ£€æŸ¥è¾“å…¥ç«¯å£æœ‰æ²¡æœ‰å½•å…¥ä¿¡å·ï¼ˆP2é«˜4ä½ï¼‰,å½•å…¥ä¿¡å·éœ€è¦é˜¶æ®µæ—¶é—´å†…ç»´æŒç¨³å®šä¿¡
             -å·
 226           * @return å¦‚æœæ²¡æœ‰ï¼Œè¿”å›0ï¼Œå¦‚æœæœ‰ï¼Œè¿”å›P2é«˜4ä½çš„ä½ä¸‰ä½ä½œä¸ºæƒé™æ•°æ®
 227           */
 228          uchar checkInputSignal(){
 229   1          uchar inputValue = GPIO_INPUT;
 230   1          uintTemp = 500;
 231   1      
 232   1          while(uintTemp--){
 233   2              ucharTemp = (inputValue>>4);
 234   2              if(ucharTemp == 0x0F)
 235   2                  return 0x00;
 236   2          }
 237   1      
 238   1          return ucharTemp;
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 10:15:35 PAGE 5   

 239   1      }
 240          
 241          /* æ ¹æ®receiveEventStatusï¼Œè§£æä¸²å£å“åº” */
 242          void receiveEventFunction(){
 243   1          switch(receiveEventStatus){
 244   2              case EVENT_GET_IMAGE_FOR_CHECK:
 245   2                  if(cfmCode == 0){
 246   3                      //ä¼ æ„Ÿå™¨é‡‡é›†åˆ°æŒ‡çº¹
 247   3                      sendCmdStatus = ACTION_BUILD_CB1_FOR_CHECK;
 248   3                  }else if(cfmCode == 2){ 
 249   3                      //ä¼ æ„Ÿå™¨ä¸Šæ²¡æœ‰æ‰‹æŒ‡ï¼Œå»¶æ—¶åç»§ç»­å‘é€é‡‡é›†å‘½ä»¤
 250   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 251   3                      delay(3000);
 252   3                  }
 253   2                  break;
 254   2              case EVENT_BUILD_CB1_FOR_CHECK:
 255   2                  if(cfmCode == 0){
 256   3                      //ç”Ÿæˆç‰¹å¾ç æˆåŠŸ
 257   3                      sendCmdStatus = ACTION_SEARCH;
 258   3                      delay(3000);
 259   3                  }else{
 260   3                      //ç”Ÿæˆç‰¹å¾ç å¤±è´¥
 261   3                      showWarning();
 262   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 263   3                      delay(3000);
 264   3                  }
 265   2                  break;
 266   2              case EVETN_SEARCH:
 267   2                  if(cfmCode == 0){
 268   3                      //@TODO:æœç´¢åˆ°åŒ¹é…æŒ‡çº¹
 269   3                      uartSendByte(receiveParams[0]);
 270   3                      uartSendByte(receiveParams[1]);
 271   3                      uintTemp = receiveParams[0];
 272   3                      uintTemp = uintTemp<<8;
 273   3                      uintTemp += receiveParams[1];
 274   3                      uintTemp = uintTemp / 100;
 275   3                      P1 = display_code[uintTemp + 1];
 276   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 277   3                      delay(65535);
 278   3                  }else{
 279   3                      //æœç´¢å¤±è´¥
 280   3                      showWarning();
 281   3                      P1 = 0x3F;
 282   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 283   3                      delay(3000);    
 284   3                  }
 285   2                  break;
 286   2          }
 287   1      }
 288          
 289          /* æ ¹æ®sendCmdStatusï¼Œæ„é€ å‘é€å‘½ä»¤ */
 290          void sendCmdFunction(){
 291   1          /* ä¸²å£æ¥å—çš„ç›¸å…³çŠ¶æ€å¤ä½ */
 292   1          receiveEventStatus = 0;
 293   1          waitForReceive = 1;
 294   1          receiveBufferLength = 0;
 295   1      
 296   1          switch(sendCmdStatus){
 297   2              case ACTION_GET_IMAGE_FOR_CHECK:
 298   2                  sendCmdAndParams[0] = 0x01;
 299   2                  buildSendCmd(1);
 300   2                  uartSendBuffer(sendBuffer, sendBufferLength);
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 10:15:35 PAGE 6   

 301   2                  delay(65535);
 302   2                  delay(65535);
 303   2                  break;
 304   2              case ACTION_BUILD_CB1_FOR_CHECK:
 305   2                  sendCmdAndParams[0] = 0x02;
 306   2                  sendCmdAndParams[1] = 0x01;
 307   2                  buildSendCmd(2);
 308   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 309   2                  delay(65535);
 310   2                  delay(65535);
 311   2                  break;
 312   2              case ACTION_SEARCH:
 313   2                  sendCmdAndParams[0] = 0x04;
 314   2                  sendCmdAndParams[1] = 0x01;
 315   2                  sendCmdAndParams[2] = 0x00;
 316   2                  sendCmdAndParams[3] = 0x00;
 317   2                  sendCmdAndParams[4] = 0x03;
 318   2                  sendCmdAndParams[5] = 0xE7;
 319   2                  buildSendCmd(6);
 320   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 321   2                  delay(65535);
 322   2                  delay(65535);
 323   2                  break;
 324   2              case ACTION_GET_FINGURE_ADDRESS_LIST0:
 325   2                  sendCmdAndParams[0] = 0x1F;
 326   2                  sendCmdAndParams[1] = 0x00;
 327   2                  buildSendCmd(2);
 328   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 329   2                  break;
 330   2              case ACTION_GET_FINGURE_ADDRESS_LIST1:
 331   2                  sendCmdAndParams[0] = 0x1F;
 332   2                  sendCmdAndParams[1] = 0x01;
 333   2                  buildSendCmd(2);
 334   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 335   2                  break;
 336   2              case ACTION_GET_FINGURE_ADDRESS_LIST2:
 337   2                  sendCmdAndParams[0] = 0x1F;
 338   2                  sendCmdAndParams[1] = 0x02;
 339   2                  buildSendCmd(2);
 340   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 341   2                  break;
 342   2              case ACTION_GET_FINGURE_ADDRESS_LIST3:
 343   2                  sendCmdAndParams[0] = 0x1F;
 344   2                  sendCmdAndParams[1] = 0x03;
 345   2                  buildSendCmd(2);
 346   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 347   2                  break;
 348   2          }
 349   1      }
 350          
 351          /* ç­‰å¾…ä¸‹ä½æœºåé¦ˆçš„å»¶æ—¶è®¡æ•°å‡½æ•° */
 352          void waitForReceiveFunction(){
 353   1          waitTimes++;
 354   1          delay(500);
 355   1      }
 356          
 357          /* å¯¹æŒ‡çº¹æ¨¡å—çš„å¤ä½å‡½æ•° */
 358          void resetFingureFunction(){
 359   1          waitTimes = 0;
 360   1      
 361   1          //@TODO:æ§åˆ¶å¼•è„šè®©æŒ‡çº¹ä¸‹ä½æœºå¤ä½
 362   1      
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 10:15:35 PAGE 7   

 363   1          delay(65535);
 364   1          delay(65535);
 365   1          delay(65535);
 366   1          delay(65535);
 367   1      
 368   1          initMain();
 369   1      }
 370          
 371          /**
 372           * è·å–æŒ‡çº¹æ¨¡å—çš„æœ‰æ•ˆæŒ‡çº¹åˆ—è¡¨
 373           * @return [0:æˆåŠŸ,1:è¶…æ—¶å¤±è´¥,2:åé¦ˆé”™è¯¯]
 374           */
 375          uchar getAddressListFunction(){
 376   1          sendCmdStatus = ACTION_GET_FINGURE_ADDRESS_LIST0;
 377   1      
 378   1          for(ut1 = 0; ut1 < 4; ut1++){
 379   2              sendCmdFunction();
 380   2              
 381   2              if(waitForReceive)
 382   2                  delay(65535);
 383   2              if(waitForReceive)
 384   2                  delay(65535);
 385   2              if(waitForReceive)
 386   2                  delay(65535);
 387   2              if(waitForReceive)
 388   2                  delay(65535);
 389   2              //ç­‰å¾…4 * 65535ä¸ªæœºå™¨æ­¥éª¤ï¼Œå¦‚æœä¾ç„¶æ²¡æœ‰åé¦ˆåˆ™å¤±è´¥
 390   2      
 391   2              if(waitForReceive)
 392   2                  return 1;
 393   2              if(cfmCode || receivePackageLength != 35)
 394   2                  return 2;
 395   2      
 396   2              //ä»ä¸²å£åé¦ˆå‚æ•°ä¸­æå–åˆ—è¡¨ç´¢å¼•æ•°æ®
 397   2              for(uintTemp = 1; uintTemp < 33; uintTemp++){
 398   3                  fingureAddressIndex[ ut1 * 32 + uintTemp - 1] = receiveParams[uintTemp];
 399   3              }
 400   2              sendCmdStatus++;    //å°†æŒ‡ä»¤ç§»åˆ°ä¸‹ä¸€é¡µ
 401   2          }
 402   1      
 403   1          P1 = 0x39;
 404   1          return 0;
 405   1      }
 406          
 407          /* @TODO:äº¤äº’åé¦ˆ */
 408          void showWarning(){
 409   1      
 410   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1085    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =    128    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49       7
   IDATA SIZE       =     76    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
