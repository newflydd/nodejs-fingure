C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE FINGURE
OBJECT MODULE PLACED IN fingure.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE fingure.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2           * @CreateTime: Mar 3, 2017 4:25 PM 
   3           * @Author: Smith Ding 
   4           * @Contact: newflydd@gmail.com 
   5           * @Last Modified By: Smith Ding
   6           * @Last Modified Time: Mar 3, 2017 4:46 PM
   7           * @Description: æœ¬è½¯ä»¶ç”¨æ¥å°†é¢æ¿ä¸æŒ‡çº¹æ¨¡å—è¿›è¡Œé€šä¿¡
   8           * @Company: JIANGSU SAIYANG MECHANICAL & ELECTRICAL TECHNOLOGY CO.,LTD
   9           */
  10          
  11          #include <reg52.h>
  12          #include <intrins.h>
  13          #include "uart.h"
  14          #include "fingure.h"
  15          #include "event.h"
  16          
  17          void delay(uint num){
  18   1          while(num--);
  19   1      }
  20          
  21          //å¯åŠ¨åˆå§‹åŒ–
  22          void initMain(){
  23   1          //åˆå§‹åŒ–å‘é€æŒ‡ä»¤å‰7ä¸ªbyte
  24   1          for(ucharTemp = 0; ucharTemp < 7; ucharTemp ++){
  25   2              sendBuffer[ucharTemp] = sendPackageHeader[ucharTemp];
  26   2          }
  27   1      
  28   1          //å°†ä¸²å£æ¥å—å¯„å­˜å™¨çš„æ•°æ®é•¿åº¦ç½®0
  29   1          receiveBufferLength = 0;
  30   1          
  31   1          //æ¥å—åˆ°äº†ä¸²å£é€šçŸ¥å¼€å…³ç½®0
  32   1          receiveCmdNotify = 0;
  33   1          //ç­‰å¾…ä¸²å£æ¶ˆæ¯å¼€å…³ç½®0
  34   1          waitForReceive = 0;
  35   1      
  36   1          EA = 1;     //æ€»ä¸­æ–­å¼€å…³æ‰“å¼€
  37   1      }
  38          
  39          void main(){    
  40   1          uchar fingureReadable = 1;      //ä¸‹ä½æœºæŒ‡çº¹æ¨¡å—è¿æ¥æ€§ï¼Œ0æ—¶ä»£è¡¨å¯å‡†ç¡®è¿æ¥
  41   1          delay(65535);
  42   1          delay(65535);
  43   1          delay(65535);
  44   1          delay(65535);
  45   1          delay(65535);
  46   1          delay(65535);
  47   1          delay(65535);
  48   1          delay(65535);
  49   1      
  50   1      initPrograme:
  51   1          initUart();
  52   1          initMain();
  53   1      
  54   1          fingureReadable = getAddressListFunction();
  55   1      
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 2   

  56   1          if(fingureReadable){
  57   2              //@TODO: å¼‚å¸¸è­¦æŠ¥
  58   2              showWarning();
  59   2              goto initPrograme;
  60   2          }else{
  61   2              //P1 = 0x40;
  62   2          }
  63   1      
  64   1          //åˆå§‹åŒ–æŒ‡ä»¤ä¸º:0x11ï¼Œå‘æŒ‡çº¹æ¨¡å—å‘é€é‡‡é›†æŒ‡çº¹ç”¨æ¥éªŒè¯çš„å‘½ä»¤
  65   1          sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
  66   1      
  67   1          while(1){
  68   2              /* ä¸»å¾ªç¯ä¸­é¦–å…ˆåˆ¤æ–­æ˜¯å¦æœ‰ä¸²å£å“åº”ï¼Œå¦‚æœæœ‰ï¼Œåˆ™æœ¬æ¬¡å¾ªç¯ç”¨æ¥å¤„ç†æ¶ˆæ¯å“
             -åº” */
  69   2              if(receiveCmdNotify == 1){
  70   3                  receiveCmdNotify = 0;
  71   3      
  72   3                  receiveEventFunction();     //æ¥ä½æ¶ˆæ¯
  73   3      
  74   3                  continue;
  75   3              }
  76   2      
  77   2              /*
  78   2               * å¦‚æœæ²¡æœ‰ä¸²å£å“åº”
  79   2               * é¦–å…ˆåˆ¤æ–­æ˜¯å¦åœ¨ç­‰å¾…ä¸‹ä½æœºåé¦ˆï¼Œå¦‚æœåœ¨ç­‰å¾…ï¼Œå°±å¼€å§‹å»¶æ—¶è®¡æ•°
  80   2               */   
  81   2              if(waitForReceive == 1){
  82   3                  waitForReceive = 0;
  83   3                  if(waitTimes < 3)
  84   3                      waitForReceiveFunction();
  85   3                  else
  86   3                      resetFingureFunction();
  87   3                  continue;
  88   3              }
  89   2      
  90   2              /* 
  91   2               * ç»§ç»­åˆ¤æ–­P2å£æœ‰æ²¡æœ‰å½•å…¥é€šçŸ¥
  92   2               * å¦‚æœæœ‰å½•å…¥é€šçŸ¥ï¼Œå¹¶ä¸”å½“å‰çŠ¶æ€ä¸ºéªŒè¯çŠ¶æ€ï¼Œåˆ™å‘é€å½•å…¥å‘½ä»¤
  93   2               * å¦‚æœæ²¡æœ‰å½•å…¥é€šçŸ¥ï¼Œåˆ™å‘é€éªŒè¯å‘½ä»¤
  94   2               */
  95   2              inputSignal = checkInputSignal();
  96   2              if((sendCmdStatus ==  ACTION_GET_IMAGE_FOR_CHECK) && inputSignal){
  97   3                  newFingureAddressIndex = getNewAddressIndexByPower(inputSignal);    //é€šè¿‡æƒé™æ¥æ„é€ ä¸€
             -ä¸ªç©ºä½ç½®
  98   3                  noFingureTimesWhenInput = 0;                                 //å°†å½•å…¥æŒ‡çº¹æ—¶çš„é‡å¤æ¬¡æ
             -•°å½’é›¶
  99   3                  sendCmdStatus = ACTION_GET_IMAGE_FOR_INPUT1;
 100   3              }
 101   2      
 102   2              //uartSendByte(sendCmdStatus);
 103   2      
 104   2              if(receiveCmdNotify == 0)
 105   2                  sendCmdFunction();
 106   2              delay(2000);
 107   2          }
 108   1      }
 109          
 110          /**
 111           * ä¸²å£ä¸­æ–­å‡½æ•°ï¼Œç”¨æ¥æ¥æ”¶ä¸‹ä½æœºæ•°æ®
 112           */
 113          void serialInterruptCallback() interrupt 4 {
 114   1        if(RI){       //æœ¬æ¬¡ä¸­æ–­æ˜¯æ¥å—ä¸­æ–­
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 3   

 115   2          RI = 0;     //æ¥å—å®Œäº†æ¸…é›¶
 116   2      
 117   2              //å°†æ¥å—åˆ°çš„å­—èŠ‚è¿½åŠ åˆ°æŒ‡ä»¤æ¥å—ç¼“å†²åŒº
 118   2          receiveByte = SBUF;
 119   2          receiveBuffer[receiveBufferLength] = receiveByte;
 120   2              receiveBufferLength++;
 121   2      
 122   2              if(receiveBufferLength == 1 && receiveByte!=0xEF){
 123   3                  receiveBufferLength = 0;
 124   3                  return;
 125   3              }
 126   2      
 127   2              if(receiveBufferLength == 2 && receiveByte!=0x01){
 128   3                  receiveBufferLength = 0;
 129   3                  return;
 130   3              }
 131   2      
 132   2              if(receiveBufferLength == 3 && receiveByte!=0xFF){
 133   3                  receiveBufferLength = 0;
 134   3                  return;
 135   3              }
 136   2      
 137   2              if(receiveBufferLength == 4 && receiveByte!=0xFF){
 138   3                  receiveBufferLength = 0;
 139   3                  return;
 140   3              }
 141   2      
 142   2              if(receiveBufferLength == 5 && receiveByte!=0xFF){
 143   3                  receiveBufferLength = 0;
 144   3                  return;
 145   3              }
 146   2      
 147   2              if(receiveBufferLength == 6 && receiveByte!=0xFF){
 148   3                  receiveBufferLength = 0;
 149   3                  return;
 150   3              }
 151   2      
 152   2              if(receiveBufferLength == 9){
 153   3                  //å¦‚æœæŒ‡ä»¤æ¥å—åˆ°9ä¸ªbyteï¼Œè¿™æ—¶å€™åŒ…é•¿åº¦ä¿¡æ¯æœ‰äº†
 154   3                  receivePackageLength = (receiveBuffer[7] << 8) + receiveBuffer[8];
 155   3              }else if (receiveBufferLength == 9 + receivePackageLength) {
 156   3                  //ç»“æŸä¸€è½®æ¶ˆæ¯æ¥å—ï¼Œæ¸…ç©ºbufferï¼Œè§£æå‘½ä»¤
 157   3                  
 158   3                  //è·å–æ ¡éªŒå’Œ
 159   3                  receiveCheckSum = (receiveBuffer[7 + receivePackageLength] << 8) + receiveBuffer[8 + receivePa
             -ckageLength];
 160   3                  //è·å–ç¡®è®¤ç 
 161   3                  cfmCode = receiveBuffer[9];
 162   3                  //è·å–å‚æ•°
 163   3                  for (ucit = 0; ucit < receivePackageLength - 3; ucit++) {
 164   4                      receiveParams[ucit] = receiveBuffer[10 + ucit];
 165   4                  }
 166   3      
 167   3                  //éªŒè¯æ ¡éªŒå’Œ
 168   3                  uiit = 0;
 169   3                  for (ucit = 6; ucit < receiveBufferLength - 2; ucit++) {
 170   4                      uiit += receiveBuffer[ucit];
 171   4                  }
 172   3      
 173   3                  if (uiit == receiveCheckSum) {
 174   4                      //æ ¡éªŒæ­£ç¡®ï¼Œå‘å°„æ¶ˆæ¯å“åº”
 175   4                      receiveCmdNotify = 1;
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 4   

 176   4                      receiveEventStatus = sendCmdStatus - 100;    //äº‹ä»¶ç±»å‹æ ¹æ®å‘é€ç±»å‹å¯¹åº”
 177   4                      waitForReceive = 0;                          //è§£é™¤ç­‰å¾…é”
 178   4                      waitTimes = 0;                               //ç­‰å¾…å“åº”æ¬¡æ•°å¤ä½
 179   4                  }
 180   3                  //æ¸…ç©ºæŒ‡ä»¤buffer
 181   3                  receiveBufferLength = 0;
 182   3              }            
 183   2        }
 184   1      }
 185          
 186          /**
 187           * ç»™sendBufferå˜é‡æ„å»ºå‘é€æŒ‡ä»¤
 188           * å‘½ä»¤å’Œå‚æ•°æ¥è‡ªäºå…¨å±€å˜é‡sendCmdAndParams
 189           * @param capLength [å‘½ä»¤+å‚æ•°çš„é•¿åº¦]
 190           */
 191          void buildSendCmd(uchar capLength){
 192   1          uint checkSum;
 193   1          uchar packageLength = capLength + 2;    //åŒ…é•¿åº¦ = æŒ‡ä»¤é›†é•¿åº¦ + æ ¡éªŒå’Œé•¿åº¦
 194   1          sendBufferLength = 11 + capLength;      // 7 + 2 + capLength + 2
 195   1      
 196   1          sendBuffer[7] = 0;                      //åŒ…é•¿åº¦é«˜ä½ä¸º0x00
 197   1          sendBuffer[8] = packageLength;          //åŒ…é•¿åº¦ä½ä½ä¸ºå®é™…åŒ…é•¿åº¦
 198   1          
 199   1          //æ„å»ºå‘é€æŒ‡ä»¤ä¸²å£æ¶ˆæ¯ä¸­çš„æŒ‡ä»¤å’Œå‚æ•°
 200   1          for(ucharTemp = 0; ucharTemp < capLength; ucharTemp++){
 201   2              sendBuffer[9+ucharTemp] = sendCmdAndParams[ucharTemp];
 202   2          }
 203   1      
 204   1          checkSum = getCheckSum(packageLength, sendCmdAndParams, capLength);
 205   1          sendBuffer[9 + capLength]  = checkSum>>8;
 206   1          sendBuffer[10 + capLength] = checkSum;
 207   1      }
 208          
 209          /**
 210           * [è®¡ç®—æ ¡éªŒå’Œ]
 211           * @param  packageLength [åŒ…é•¿åº¦]
 212           * @param  cmdAndParams  [å‘½ä»¤å’Œå‚æ•°æ•°ç»„]
 213           * @param  capLength     [å‘½ä»¤å’Œå‚æ•°é•¿åº¦]
 214           * @return               [2byte æ ¡éªŒå’Œ]
 215           */
 216          uint getCheckSum(uchar packageLength, uchar* cmdAndParams, uchar capLength){
 217   1          uintTemp = packageLength;
 218   1          for(ucharTemp = 0; ucharTemp < capLength; ucharTemp++){
 219   2              uintTemp += cmdAndParams[ucharTemp];
 220   2          }
 221   1          return uintTemp + 1;
 222   1      }
 223          
 224          /**
 225           * @TODO:ä¸´æ—¶æ¨¡æ‹Ÿä¿¡å·
 226           * æ£€æŸ¥è¾“å…¥ç«¯å£æœ‰æ²¡æœ‰å½•å…¥ä¿¡å·ï¼ˆP2é«˜4ä½ï¼‰,å½•å…¥ä¿¡å·éœ€è¦é˜¶æ®µæ—¶é—´å†…ç»´æŒç¨³å®šä¿¡
             -å·
 227           * @return å¦‚æœæ²¡æœ‰ï¼Œè¿”å›0ï¼Œå¦‚æœæœ‰ï¼Œè¿”å›P2é«˜4ä½çš„ä½ä¸‰ä½ä½œä¸ºæƒé™æ•°æ®
 228           */
 229          uchar checkInputSignal(){
 230   1          uchar inputValue = GPIO_INPUT;
 231   1          uintTemp = 500;
 232   1      
 233   1          while(uintTemp--){
 234   2              ucharTemp = (inputValue<<1);
 235   2              if((ucharTemp & 0x80) == 0x80)
 236   2                  return 0x00;
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 5   

 237   2          }
 238   1      
 239   1          return 0x05;
 240   1      }
 241          
 242          /* æ ¹æ®receiveEventStatusï¼Œè§£æä¸²å£å“åº” */
 243          void receiveEventFunction(){
 244   1          switch(receiveEventStatus){
 245   2              case EVENT_GET_IMAGE_FOR_CHECK:
 246   2                  if(cfmCode == 0){
 247   3                      //ä¼ æ„Ÿå™¨é‡‡é›†åˆ°æŒ‡çº¹
 248   3                      sendCmdStatus = ACTION_BUILD_CB1_FOR_CHECK;
 249   3                  }else if(cfmCode == 2){ 
 250   3                      //ä¼ æ„Ÿå™¨ä¸Šæ²¡æœ‰æ‰‹æŒ‡ï¼Œå»¶æ—¶åç»§ç»­å‘é€é‡‡é›†å‘½ä»¤
 251   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 252   3                      delay(3000);
 253   3                  }
 254   2                  break;
 255   2              case EVENT_BUILD_CB1_FOR_CHECK:
 256   2                  if(cfmCode == 0){
 257   3                      //ç”Ÿæˆç‰¹å¾ç æˆåŠŸ
 258   3                      sendCmdStatus = ACTION_SEARCH;
 259   3                      delay(3000);
 260   3                  }else{
 261   3                      //ç”Ÿæˆç‰¹å¾ç å¤±è´¥
 262   3                      showWarning();
 263   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 264   3                      delay(3000);
 265   3                  }
 266   2                  break;
 267   2              case EVETN_SEARCH:
 268   2                  if(cfmCode == 0){
 269   3                      //@TODO:æœç´¢åˆ°åŒ¹é…æŒ‡çº¹
 270   3                      uartSendByte(receiveParams[0]);
 271   3                      uartSendByte(receiveParams[1]);
 272   3                      uintTemp = receiveParams[0];
 273   3                      uintTemp = uintTemp<<8;
 274   3                      uintTemp += receiveParams[1];
 275   3                      uintTemp = uintTemp / 100;
 276   3                      P1 = display_code[uintTemp + 1];
 277   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 278   3                      delay(65535);
 279   3                  }else{
 280   3                      //æœç´¢å¤±è´¥
 281   3                      showWarning();
 282   3                      P1 = 0x3F;
 283   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 284   3                      delay(3000);    
 285   3                  }
 286   2                  break;
 287   2              case EVENT_GET_IMAGE_FOR_INPUT1:
 288   2                  if(cfmCode == 0){
 289   3                      //ä¼ æ„Ÿå™¨é‡‡é›†åˆ°æŒ‡çº¹
 290   3                      sendCmdStatus = ACTION_BUILD_CB1_FOR_INPUT;
 291   3                      noFingureTimesWhenInput = 0;        //å½•å…¥æ—¶æ²¡æœ‰æŒ‡çº¹çš„æ¬¡æ•°å½’é›¶
 292   3                  }else if(cfmCode == 2){ 
 293   3                      //ä¼ æ„Ÿå™¨ä¸Šæ²¡æœ‰æ‰‹æŒ‡ï¼Œå»¶æ—¶åç»§ç»­å‘é€é‡‡é›†å‘½ä»¤ï¼Œè®¡æ•°30æ¬¡åé‡ç½®ä¸ºéª
             -Œè¯æŒ‡çº¹
 294   3                      noFingureTimesWhenInput++;
 295   3                      if(noFingureTimesWhenInput > NO_FINGURE_WHEN_INPUT_MAX_TIME)
 296   3                          sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 297   3                      else    
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 6   

 298   3                          sendCmdStatus = ACTION_GET_IMAGE_FOR_INPUT1;
 299   3                      delay(3000);
 300   3                  }
 301   2                  break;
 302   2              case EVENT_BUILD_CB1_FOR_INPUT:
 303   2                  if(cfmCode == 0){
 304   3                      //ç”Ÿæˆç‰¹å¾ç æˆåŠŸ
 305   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_INPUT2;
 306   3                      delay(3000);
 307   3                  }else{
 308   3                      //ç”Ÿæˆç‰¹å¾ç å¤±è´¥
 309   3                      showWarning();
 310   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_INPUT1;
 311   3                      delay(3000);
 312   3                  }
 313   2                  break;
 314   2              case EVENT_GET_IMAGE_FOR_INPUT2:
 315   2                  if(cfmCode == 0){
 316   3                      //ä¼ æ„Ÿå™¨é‡‡é›†åˆ°æŒ‡çº¹
 317   3                      sendCmdStatus = ACTION_BUILD_CB2_FOR_INPUT;
 318   3                      noFingureTimesWhenInput = 0;
 319   3                  }else if(cfmCode == 2){ 
 320   3                      //ä¼ æ„Ÿå™¨ä¸Šæ²¡æœ‰æ‰‹æŒ‡ï¼Œå»¶æ—¶åç»§ç»­å‘é€é‡‡é›†å‘½ä»¤ï¼Œè®¡æ•°30æ¬¡åé‡ç½®ä¸ºéª
             -Œè¯æŒ‡çº¹
 321   3                      noFingureTimesWhenInput++;
 322   3                      if(noFingureTimesWhenInput > NO_FINGURE_WHEN_INPUT_MAX_TIME)
 323   3                          sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 324   3                      else    
 325   3                          sendCmdStatus = ACTION_GET_IMAGE_FOR_INPUT2;
 326   3                      delay(3000);
 327   3                  }
 328   2                  break;
 329   2              case EVENT_BUILD_CB2_FOR_INPUT:
 330   2                  if(cfmCode == 0){
 331   3                      //ç”Ÿæˆç‰¹å¾ç æˆåŠŸ
 332   3                      sendCmdStatus = ACTION_MEARGE_CODE;
 333   3                      delay(3000);
 334   3                  }else{
 335   3                      //ç”Ÿæˆç‰¹å¾ç å¤±è´¥
 336   3                      showWarning();
 337   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_INPUT2;
 338   3                      delay(3000);
 339   3                  }
 340   2                  break;
 341   2              case EVENT_MEARGE_CODE:
 342   2                  if(cfmCode == 0){
 343   3                      //ç‰¹å¾ç åˆå¹¶æˆåŠŸ
 344   3                      sendCmdStatus = ACTION_SAVE_ADDRESS;
 345   3                      delay(3000);
 346   3                  }else{
 347   3                      //ç‰¹å¾ç åˆå¹¶å¤±è´¥
 348   3                      showWarning();
 349   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 350   3                      delay(3000);
 351   3                  }
 352   2                  break;
 353   2              case EVENT_SAVE_ADDRESS:
 354   2                  if(cfmCode == 0){
 355   3                      //æŒ‡çº¹ç‰¹å¾ä¿å­˜æˆåŠŸ
 356   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 357   3                      delay(3000);
 358   3                      updateFingureAddress(newFingureAddressIndex);
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 7   

 359   3                  }else{
 360   3                      //ç‰¹å¾ç åˆå¹¶å¤±è´¥
 361   3                      showWarning();
 362   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 363   3                      delay(3000);
 364   3                  }
 365   2                  break;
 366   2          }
 367   1      }
 368          
 369          /* æ ¹æ®sendCmdStatusï¼Œæ„é€ å‘é€å‘½ä»¤ */
 370          void sendCmdFunction(){
 371   1          /* ä¸²å£æ¥å—çš„ç›¸å…³çŠ¶æ€å¤ä½ */
 372   1          receiveEventStatus = 0;
 373   1          waitForReceive = 1;
 374   1          receiveBufferLength = 0;
 375   1      
 376   1          switch(sendCmdStatus){
 377   2              case ACTION_GET_IMAGE_FOR_CHECK:
 378   2                  P1 = display_code[10];
 379   2                  sendCmdAndParams[0] = 0x01;
 380   2                  buildSendCmd(1);
 381   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 382   2                  delay(65535);
 383   2                  break;
 384   2              case ACTION_BUILD_CB1_FOR_CHECK:
 385   2                  sendCmdAndParams[0] = 0x02;
 386   2                  sendCmdAndParams[1] = 0x01;
 387   2                  buildSendCmd(2);
 388   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 389   2                  delay(65535);
 390   2                  break;
 391   2              case ACTION_SEARCH:
 392   2                  sendCmdAndParams[0] = 0x04;
 393   2                  sendCmdAndParams[1] = 0x01;
 394   2                  sendCmdAndParams[2] = 0x00;
 395   2                  sendCmdAndParams[3] = 0x00;
 396   2                  sendCmdAndParams[4] = 0x03;
 397   2                  sendCmdAndParams[5] = 0xE7;
 398   2                  buildSendCmd(6);
 399   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 400   2                  delay(65535);
 401   2                  break;
 402   2              case ACTION_GET_FINGURE_ADDRESS_LIST0:
 403   2                  sendCmdAndParams[0] = 0x1F;
 404   2                  sendCmdAndParams[1] = 0x00;
 405   2                  buildSendCmd(2);
 406   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 407   2                  break;
 408   2              case ACTION_GET_FINGURE_ADDRESS_LIST1:
 409   2                  sendCmdAndParams[0] = 0x1F;
 410   2                  sendCmdAndParams[1] = 0x01;
 411   2                  buildSendCmd(2);
 412   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 413   2                  break;
 414   2              case ACTION_GET_FINGURE_ADDRESS_LIST2:
 415   2                  sendCmdAndParams[0] = 0x1F;
 416   2                  sendCmdAndParams[1] = 0x02;
 417   2                  buildSendCmd(2);
 418   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 419   2                  break;
 420   2              case ACTION_GET_FINGURE_ADDRESS_LIST3:
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 8   

 421   2                  sendCmdAndParams[0] = 0x1F;
 422   2                  sendCmdAndParams[1] = 0x03;
 423   2                  buildSendCmd(2);
 424   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 425   2                  break;
 426   2              case ACTION_GET_IMAGE_FOR_INPUT1:
 427   2                  P1 = display_code[11];
 428   2                  sendCmdAndParams[0] = 0x01;
 429   2                  buildSendCmd(1);
 430   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 431   2                  delay(65535);
 432   2                  break;
 433   2              case ACTION_GET_IMAGE_FOR_INPUT2:
 434   2                  sendCmdAndParams[0] = 0x01;
 435   2                  buildSendCmd(1);
 436   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 437   2                  delay(65535);
 438   2                  break;
 439   2              case ACTION_BUILD_CB1_FOR_INPUT:
 440   2                  sendCmdAndParams[0] = 0x02;
 441   2                  sendCmdAndParams[1] = 0x01;
 442   2                  buildSendCmd(2);
 443   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 444   2                  delay(65535);
 445   2                  break;
 446   2              case ACTION_BUILD_CB2_FOR_INPUT:
 447   2                  sendCmdAndParams[0] = 0x02;
 448   2                  sendCmdAndParams[1] = 0x02;
 449   2                  buildSendCmd(2);
 450   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 451   2                  delay(65535);
 452   2                  break;
 453   2              case ACTION_MEARGE_CODE:
 454   2                  sendCmdAndParams[0] = 0x05;
 455   2                  buildSendCmd(1);
 456   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 457   2                  delay(65535);
 458   2                  break;
 459   2              case ACTION_SAVE_ADDRESS:
 460   2                  sendCmdAndParams[0] = 0x06;
 461   2                  sendCmdAndParams[1] = 0x01;
 462   2                  sendCmdAndParams[2] = (uchar)(newFingureAddressIndex>>8);
 463   2                  sendCmdAndParams[3] = (uchar)newFingureAddressIndex;
 464   2                  buildSendCmd(4);
 465   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 466   2                  delay(65535);
 467   2                  break;
 468   2          }
 469   1      }
 470          
 471          /* ç­‰å¾…ä¸‹ä½æœºåé¦ˆçš„å»¶æ—¶è®¡æ•°å‡½æ•° */
 472          void waitForReceiveFunction(){
 473   1          waitTimes++;
 474   1          delay(500);
 475   1      }
 476          
 477          /* å¯¹æŒ‡çº¹æ¨¡å—çš„å¤ä½å‡½æ•° */
 478          void resetFingureFunction(){
 479   1          waitTimes = 0;
 480   1      
 481   1          //@TODO:æ§åˆ¶å¼•è„šè®©æŒ‡çº¹ä¸‹ä½æœºå¤ä½
 482   1      
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 9   

 483   1          delay(65535);
 484   1          delay(65535);
 485   1          delay(65535);
 486   1          delay(65535);
 487   1      
 488   1          initMain();
 489   1          sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 490   1      }
 491          
 492          /**
 493           * è·å–æŒ‡çº¹æ¨¡å—çš„æœ‰æ•ˆæŒ‡çº¹åˆ—è¡¨
 494           * @return [0:æˆåŠŸ,1:è¶…æ—¶å¤±è´¥,2:åé¦ˆé”™è¯¯]
 495           */
 496          uchar getAddressListFunction(){
 497   1          sendCmdStatus = ACTION_GET_FINGURE_ADDRESS_LIST0;
 498   1      
 499   1          for(ut1 = 0; ut1 < 4; ut1++){
 500   2              sendCmdFunction();
 501   2              
 502   2              if(waitForReceive)
 503   2                  delay(65535);
 504   2              if(waitForReceive)
 505   2                  delay(65535);
 506   2              if(waitForReceive)
 507   2                  delay(65535);
 508   2              if(waitForReceive)
 509   2                  delay(65535);
 510   2              //ç­‰å¾…4 * 65535ä¸ªæœºå™¨æ­¥éª¤ï¼Œå¦‚æœä¾ç„¶æ²¡æœ‰åé¦ˆåˆ™å¤±è´¥
 511   2      
 512   2              if(waitForReceive)
 513   2                  return 1;
 514   2              if(cfmCode || receivePackageLength != 35)
 515   2                  return 2;
 516   2      
 517   2              //ä»ä¸²å£åé¦ˆå‚æ•°ä¸­æå–åˆ—è¡¨ç´¢å¼•æ•°æ®
 518   2              for(uintTemp = 0; uintTemp < 33; uintTemp++){
 519   3                  fingureAddressIndex[ ut1 * 32 + uintTemp] = receiveParams[uintTemp];
 520   3              }
 521   2              sendCmdStatus++;    //å°†æŒ‡ä»¤ç§»åˆ°ä¸‹ä¸€é¡µ
 522   2          }
 523   1      
 524   1          return 0;
 525   1      }
 526          
 527          /**
 528           * æ ¹æ®å†…å­˜ä¸­çš„æŒ‡çº¹åº“ï¼Œå’Œä¼ å…¥çš„æƒé™ï¼Œæ„é€ ä¸€ä¸ªæ–°çš„æœªä½¿ç”¨çš„æŒ‡çº¹ç´¢å¼•
 529           * @param  uchar [æƒé™ï¼Œ1-10]
 530           * @return       [æœªä½¿ç”¨çš„æŒ‡çº¹åº“ç´¢å¼•]
 531           */
 532          uint  getNewAddressIndexByPower(uchar power){
 533   1          uintTemp = (power - 1) * 100;
 534   1          ucharTemp = fingureAddressIndex[uintTemp / 8]<<(uintTemp % 8);
 535   1          while((ucharTemp & 0x80) == 0x80){
 536   2              uintTemp++;
 537   2              ucharTemp = fingureAddressIndex[uintTemp / 8]<<(uintTemp % 8);
 538   2          }
 539   1          return uintTemp;
 540   1      }
 541          
 542          /**
 543           * æ›´æ–°æŒ‡çº¹åº“ï¼Œå°†æŒ‡å®šä½ç½®çš„bitç½®ä¸º1
 544           * @param  address [æŒ‡å®šåœ°å€]
C51 COMPILER V9.52.0.0   FINGURE                                                           03/10/2017 16:03:05 PAGE 10  

 545           * @return         []
 546           */
 547          void  updateFingureAddress(uint address){
 548   1          ucharTemp = fingureAddressIndex[address/8];
 549   1          ut1 = 0x80 >> (address % 8);
 550   1          ucharTemp = ucharTemp | ut1;
 551   1          fingureAddressIndex[address/8] = ucharTemp;
 552   1      }
 553          
 554          /* @TODO:äº¤äº’åé¦ˆ */
 555          void showWarning(){
 556   1      
 557   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1575    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =    128    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52       7
   IDATA SIZE       =     76    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
