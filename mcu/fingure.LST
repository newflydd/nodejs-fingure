C51 COMPILER V9.52.0.0   FINGURE                                                           03/09/2017 18:05:58 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE FINGURE
OBJECT MODULE PLACED IN fingure.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE fingure.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2           * @CreateTime: Mar 3, 2017 4:25 PM 
   3           * @Author: Smith Ding 
   4           * @Contact: newflydd@gmail.com 
   5           * @Last Modified By: Smith Ding
   6           * @Last Modified Time: Mar 3, 2017 4:46 PM
   7           * @Description: æœ¬è½¯ä»¶ç”¨æ¥å°†é¢æ¿ä¸æŒ‡çº¹æ¨¡å—è¿›è¡Œé€šä¿¡
   8           * @Company: JIANGSU SAIYANG MECHANICAL & ELECTRICAL TECHNOLOGY CO.,LTD
   9           */
  10          
  11          #include <reg52.h>
  12          #include <intrins.h>
  13          #include "uart.h"
  14          #include "fingure.h"
  15          #include "event.h"
  16          
  17          void delay(uint num){
  18   1          while(num--);
  19   1      }
  20          
  21          //å¯åŠ¨åˆå§‹åŒ–
  22          void initMain(){
  23   1          //åˆå§‹åŒ–å‘é€æŒ‡ä»¤å‰7ä¸ªbyte
  24   1          for(ucharTemp = 0; ucharTemp < 7; ucharTemp ++){
  25   2              sendBuffer[ucharTemp] = sendPackageHeader[ucharTemp];
  26   2          }
  27   1      
  28   1          //å°†ä¸²å£æ¥å—å¯„å­˜å™¨çš„æ•°æ®é•¿åº¦ç½®0
  29   1          receiveBufferLength = 0;
  30   1          
  31   1          //æ¥å—åˆ°äº†ä¸²å£é€šçŸ¥å¼€å…³ç½®0
  32   1          receiveCmdNotify = 0;
  33   1          //ç­‰å¾…ä¸²å£æ¶ˆæ¯å¼€å…³ç½®0
  34   1          waitForReceive = 0;
  35   1      
  36   1          EA = 1;     //æ€»ä¸­æ–­å¼€å…³æ‰“å¼€
  37   1      }
  38          
  39          void main(){    
  40   1          uchar fingureReadable = 1;      //ä¸‹ä½æœºæŒ‡çº¹æ¨¡å—è¿æ¥æ€§ï¼Œ0æ—¶ä»£è¡¨å¯å‡†ç¡®è¿æ¥
  41   1          P1 = 0x3F;                      //@TODO:ä¸´æ—¶å°†æ•°ç ç®¡ç½®0
  42   1          delay(65535);
  43   1          delay(65535);
  44   1          delay(65535);
  45   1          delay(65535);
  46   1          delay(65535);
  47   1          delay(65535);
  48   1          delay(65535);
  49   1          delay(65535);
  50   1      
  51   1      initPrograme:
  52   1          initUart();
  53   1          initMain();
  54   1      
  55   1          fingureReadable = getAddressListFunction();
C51 COMPILER V9.52.0.0   FINGURE                                                           03/09/2017 18:05:58 PAGE 2   

  56   1      
  57   1          if(fingureReadable){
  58   2              //@TODO: å¼‚å¸¸è­¦æŠ¥
  59   2              //P1 = display_code[fingureReadable];
  60   2              showWarning();
  61   2              goto initPrograme;
  62   2          }else{
  63   2              P1 = 0x40;
  64   2          }
  65   1      
  66   1          //åˆå§‹åŒ–æŒ‡ä»¤ä¸º:0x11ï¼Œå‘æŒ‡çº¹æ¨¡å—å‘é€é‡‡é›†æŒ‡çº¹ç”¨æ¥éªŒè¯çš„å‘½ä»¤
  67   1          sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
  68   1      
  69   1          while(1){
  70   2              /* ä¸»å¾ªç¯ä¸­é¦–å…ˆåˆ¤æ–­æ˜¯å¦æœ‰ä¸²å£å“åº”ï¼Œå¦‚æœæœ‰ï¼Œåˆ™æœ¬æ¬¡å¾ªç¯ç”¨æ¥å¤„ç†æ¶ˆæ¯å“
             -åº” */
  71   2              if(receiveCmdNotify == 1){
  72   3                  receiveCmdNotify = 0;
  73   3      
  74   3                  receiveEventFunction();     //æ¥ä½æ¶ˆæ¯
  75   3      
  76   3                  continue;
  77   3              }
  78   2      
  79   2              /*
  80   2               * å¦‚æœæ²¡æœ‰ä¸²å£å“åº”
  81   2               * é¦–å…ˆåˆ¤æ–­æ˜¯å¦åœ¨ç­‰å¾…ä¸‹ä½æœºåé¦ˆï¼Œå¦‚æœåœ¨ç­‰å¾…ï¼Œå°±å¼€å§‹å»¶æ—¶è®¡æ•°
  82   2               */   
  83   2              if(waitForReceive == 1){
  84   3                  waitForReceive = 0;
  85   3                  if(waitTimes < 3)
  86   3                      waitForReceiveFunction();
  87   3                  else
  88   3                      resetFingureFunction();
  89   3                  continue;
  90   3              }
  91   2      
  92   2              /* 
  93   2               * ç»§ç»­åˆ¤æ–­P2å£æœ‰æ²¡æœ‰å½•å…¥é€šçŸ¥
  94   2               * å¦‚æœæœ‰å½•å…¥é€šçŸ¥ï¼Œå¹¶ä¸”å½“å‰çŠ¶æ€ä¸ºéªŒè¯çŠ¶æ€ï¼Œåˆ™å‘é€å½•å…¥å‘½ä»¤
  95   2               * å¦‚æœæ²¡æœ‰å½•å…¥é€šçŸ¥ï¼Œåˆ™å‘é€éªŒè¯å‘½ä»¤
  96   2               */
  97   2              inputSignal = checkInputSignal();
  98   2              if((sendCmdStatus ==  ACTION_GET_IMAGE_FOR_CHECK) && inputSignal){
  99   3                  sendCmdStatus = ACTION_GET_IMAGE_FOR_INPUT1;
 100   3              }
 101   2      
 102   2              //uartSendByte(sendCmdStatus);
 103   2      
 104   2              if(receiveCmdNotify == 0)
 105   2                  sendCmdFunction();
 106   2              delay(2000);
 107   2          }
 108   1      }
 109          
 110          /**
 111           * ä¸²å£ä¸­æ–­å‡½æ•°ï¼Œç”¨æ¥æ¥æ”¶ä¸‹ä½æœºæ•°æ®
 112           */
 113          void serialInterruptCallback() interrupt 4 {
 114   1          uchar ucit;         //ä¸­æ–­ä¸­è‡ªå·±ä½¿ç”¨çš„ucharå˜é‡ï¼Œä¸­æ–­ä¸­ç¦æ­¢ä½¿ç”¨ä»»ä½•å…¨å±€ä¸´æ—¶å˜
             -é‡
 115   1          uint  uiit;         //ä¸­æ–­ä¸­è‡ªå·±ä½¿ç”¨çš„uint å˜é‡ï¼Œä¸­æ–­ä¸­ç¦æ­¢ä½¿ç”¨ä»»ä½•å…¨å±€ä¸´æ—¶å˜
C51 COMPILER V9.52.0.0   FINGURE                                                           03/09/2017 18:05:58 PAGE 3   

             -é‡
 116   1        if(RI){       //æœ¬æ¬¡ä¸­æ–­æ˜¯æ¥å—ä¸­æ–­
 117   2          RI = 0;     //æ¥å—å®Œäº†æ¸…é›¶
 118   2      
 119   2              //å°†æ¥å—åˆ°çš„å­—èŠ‚è¿½åŠ åˆ°æŒ‡ä»¤æ¥å—ç¼“å†²åŒº
 120   2          receiveByte = SBUF;
 121   2          receiveBuffer[receiveBufferLength] = receiveByte;
 122   2              receiveBufferLength++;
 123   2      
 124   2              P1 = display_code[ receiveBufferLength>>4 & 0x0F ];
 125   2      
 126   2              if(receiveBufferLength == 1 && receiveByte!=0xEF)
 127   2                  receiveBufferLength = 0;
 128   2      
 129   2              if(receiveBufferLength == 2 && receiveByte!=0x01)
 130   2                  receiveBufferLength = 0;
 131   2      
 132   2              if(receiveBufferLength == 3 && receiveByte!=0xFF)
 133   2                  receiveBufferLength = 0;
 134   2      
 135   2              if(receiveBufferLength == 4 && receiveByte!=0xFF)
 136   2                  receiveBufferLength = 0;
 137   2      
 138   2              if(receiveBufferLength == 5 && receiveByte!=0xFF)
 139   2                  receiveBufferLength = 0;
 140   2      
 141   2              if(receiveBufferLength == 6 && receiveByte!=0xFF)
 142   2                  receiveBufferLength = 0;
 143   2      
 144   2              if(receiveBufferLength == 9){
 145   3                  //å¦‚æœæŒ‡ä»¤æ¥å—åˆ°9ä¸ªbyteï¼Œè¿™æ—¶å€™åŒ…é•¿åº¦ä¿¡æ¯æœ‰äº†
 146   3                  receivePackageLength = (receiveBuffer[7] << 8) + receiveBuffer[8];
 147   3              }else if (receiveBufferLength == 9 + receivePackageLength) {
 148   3                  //ç»“æŸä¸€è½®æ¶ˆæ¯æ¥å—ï¼Œæ¸…ç©ºbufferï¼Œè§£æå‘½ä»¤            
 149   3                  
 150   3                  //è·å–æ ¡éªŒå’Œ
 151   3                  receiveCheckSum = (receiveBuffer[7 + receivePackageLength] << 8) + receiveBuffer[8 + receivePa
             -ckageLength];
 152   3                  //è·å–ç¡®è®¤ç 
 153   3                  cfmCode = receiveBuffer[9];
 154   3                  //è·å–å‚æ•°
 155   3                  for (ucit = 0; ucit < receivePackageLength - 3; ucit++) {
 156   4                      receiveParams[ucit] = receiveBuffer[10 + ucit];
 157   4                  }
 158   3      
 159   3                  //éªŒè¯æ ¡éªŒå’Œ
 160   3                  uiit = 0;
 161   3                  for (ucit = 6; ucit < receiveBufferLength - 2; ucit++) {
 162   4                      uiit += receiveBuffer[ucit];
 163   4                  }
 164   3      
 165   3                  if (uiit == receiveCheckSum) {
 166   4                      //æ ¡éªŒæ­£ç¡®ï¼Œå‘å°„æ¶ˆæ¯å“åº”
 167   4                      receiveCmdNotify = 1;
 168   4                      receiveEventStatus = sendCmdStatus - 100;    //äº‹ä»¶ç±»å‹æ ¹æ®å‘é€ç±»å‹å¯¹åº”
 169   4                      waitForReceive = 0;                          //è§£é™¤ç­‰å¾…é”
 170   4                      waitTimes = 0;                               //ç­‰å¾…å“åº”æ¬¡æ•°å¤ä½
 171   4      
 172   4                      REN = 0;    //å¿…é¡»æ¶ˆæ¯å“åº”åæ‰èƒ½ç»§ç»­æ¥å—ï¼Œæ¥å—å“åº”åéœ€è¦äººå·¥å°†RENå
             -¤ä½ä¸º1
 173   4                  }
 174   3                  //æ¸…ç©ºæŒ‡ä»¤buffer
C51 COMPILER V9.52.0.0   FINGURE                                                           03/09/2017 18:05:58 PAGE 4   

 175   3                  receiveBufferLength = 0;
 176   3              }            
 177   2        }
 178   1      }
 179          
 180          /**
 181           * ç»™sendBufferå˜é‡æ„å»ºå‘é€æŒ‡ä»¤
 182           * å‘½ä»¤å’Œå‚æ•°æ¥è‡ªäºå…¨å±€å˜é‡sendCmdAndParams
 183           * @param capLength [å‘½ä»¤+å‚æ•°çš„é•¿åº¦]
 184           */
 185          void buildSendCmd(uchar capLength){
 186   1          uint checkSum;
 187   1          uchar packageLength = capLength + 2;    //åŒ…é•¿åº¦ = æŒ‡ä»¤é›†é•¿åº¦ + æ ¡éªŒå’Œé•¿åº¦
 188   1          sendBufferLength = 11 + capLength;      // 7 + 2 + capLength + 2
 189   1      
 190   1          sendBuffer[7] = 0;                      //åŒ…é•¿åº¦é«˜ä½ä¸º0x00
 191   1          sendBuffer[8] = packageLength;          //åŒ…é•¿åº¦ä½ä½ä¸ºå®é™…åŒ…é•¿åº¦
 192   1          
 193   1          //æ„å»ºå‘é€æŒ‡ä»¤ä¸²å£æ¶ˆæ¯ä¸­çš„æŒ‡ä»¤å’Œå‚æ•°
 194   1          for(ucharTemp = 0; ucharTemp < capLength; ucharTemp++){
 195   2              sendBuffer[9+ucharTemp] = sendCmdAndParams[ucharTemp];
 196   2          }
 197   1      
 198   1          checkSum = getCheckSum(packageLength, sendCmdAndParams, capLength);
 199   1          sendBuffer[9 + capLength]  = checkSum>>8;
 200   1          sendBuffer[10 + capLength] = checkSum;
 201   1      }
 202          
 203          /**
 204           * [è®¡ç®—æ ¡éªŒå’Œ]
 205           * @param  packageLength [åŒ…é•¿åº¦]
 206           * @param  cmdAndParams  [å‘½ä»¤å’Œå‚æ•°æ•°ç»„]
 207           * @param  capLength     [å‘½ä»¤å’Œå‚æ•°é•¿åº¦]
 208           * @return               [2byte æ ¡éªŒå’Œ]
 209           */
 210          uint getCheckSum(uchar packageLength, uchar* cmdAndParams, uchar capLength){
 211   1          uintTemp = packageLength;
 212   1          for(ucharTemp = 0; ucharTemp < capLength; ucharTemp++){
 213   2              uintTemp += cmdAndParams[ucharTemp];
 214   2          }
 215   1          return uintTemp + 1;
 216   1      }
 217          
 218          /**
 219           * æ£€æŸ¥è¾“å…¥ç«¯å£æœ‰æ²¡æœ‰å½•å…¥ä¿¡å·ï¼ˆP2é«˜4ä½ï¼‰,å½•å…¥ä¿¡å·éœ€è¦é˜¶æ®µæ—¶é—´å†…ç»´æŒç¨³å®šä¿¡
             -å·
 220           * @return å¦‚æœæ²¡æœ‰ï¼Œè¿”å›0ï¼Œå¦‚æœæœ‰ï¼Œè¿”å›P2é«˜4ä½çš„ä½ä¸‰ä½ä½œä¸ºæƒé™æ•°æ®
 221           */
 222          uchar checkInputSignal(){
 223   1          uchar inputValue = GPIO_INPUT;
 224   1          uintTemp = 500;
 225   1      
 226   1          while(uintTemp--){
 227   2              ucharTemp = (inputValue>>4);
 228   2              if(ucharTemp == 0x0F)
 229   2                  return 0x00;
 230   2          }
 231   1      
 232   1          return ucharTemp;
 233   1      }
 234          
 235          /* æ ¹æ®receiveEventStatusï¼Œè§£æä¸²å£å“åº” */
C51 COMPILER V9.52.0.0   FINGURE                                                           03/09/2017 18:05:58 PAGE 5   

 236          void receiveEventFunction(){
 237   1          switch(receiveEventStatus){
 238   2              case EVENT_GET_IMAGE_FOR_CHECK:
 239   2                  if(cfmCode == 0){
 240   3                      //ä¼ æ„Ÿå™¨é‡‡é›†åˆ°æŒ‡çº¹
 241   3                      sendCmdStatus = ACTION_BUILD_CB1_FOR_CHECK;
 242   3                  }else if(cfmCode == 2){ 
 243   3                      //ä¼ æ„Ÿå™¨ä¸Šæ²¡æœ‰æ‰‹æŒ‡ï¼Œå»¶æ—¶åç»§ç»­å‘é€é‡‡é›†å‘½ä»¤
 244   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 245   3                      delay(3000);
 246   3                  }
 247   2                  break;
 248   2              case EVENT_BUILD_CB1_FOR_CHECK:
 249   2                  if(cfmCode == 0){
 250   3                      //ç”Ÿæˆç‰¹å¾ç æˆåŠŸ
 251   3                      sendCmdStatus = ACTION_SEARCH;
 252   3                      delay(3000);
 253   3                  }else{
 254   3                      //ç”Ÿæˆç‰¹å¾ç å¤±è´¥
 255   3                      showWarning();
 256   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 257   3                      delay(3000);
 258   3                  }
 259   2                  break;
 260   2              case EVETN_SEARCH:
 261   2                  if(cfmCode == 0){
 262   3                      //@TODO:æœç´¢åˆ°åŒ¹é…æŒ‡çº¹
 263   3                      uartSendByte(receiveParams[0]);
 264   3                      uartSendByte(receiveParams[1]);
 265   3                      uintTemp = receiveParams[0];
 266   3                      uintTemp = uintTemp<<8;
 267   3                      uintTemp += receiveParams[1];
 268   3                      uintTemp = uintTemp / 100;
 269   3                      P1 = display_code[uintTemp + 1];
 270   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 271   3                      delay(65535);
 272   3                  }else{
 273   3                      //æœç´¢å¤±è´¥
 274   3                      showWarning();
 275   3                      P1 = 0x3F;
 276   3                      sendCmdStatus = ACTION_GET_IMAGE_FOR_CHECK;
 277   3                      delay(3000);    
 278   3                  }
 279   2                  break;
 280   2          }
 281   1      }
 282          
 283          /* æ ¹æ®sendCmdStatusï¼Œæ„é€ å‘é€å‘½ä»¤ */
 284          void sendCmdFunction(){
 285   1          REN = 0;
 286   1      
 287   1          /* ä¸²å£æ¥å—çš„ç›¸å…³çŠ¶æ€å¤ä½ */
 288   1          receiveEventStatus = 0;
 289   1          waitForReceive = 1;
 290   1          receiveBufferLength = 0;
 291   1      
 292   1          switch(sendCmdStatus){
 293   2              case ACTION_GET_IMAGE_FOR_CHECK:
 294   2                  sendCmdAndParams[0] = 0x01;
 295   2                  buildSendCmd(1);
 296   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 297   2                  REN = 1;    //å‘é€å®Œæˆåï¼Œç«‹åˆ»å°†æ¥å—ç­‰å¾…æ ‡å¿—ç½®1ï¼Œç­‰å¾…æ¥å—
C51 COMPILER V9.52.0.0   FINGURE                                                           03/09/2017 18:05:58 PAGE 6   

 298   2                  delay(65535);
 299   2                  delay(65535);
 300   2                  break;
 301   2              case ACTION_BUILD_CB1_FOR_CHECK:
 302   2                  sendCmdAndParams[0] = 0x02;
 303   2                  sendCmdAndParams[1] = 0x01;
 304   2                  buildSendCmd(2);
 305   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 306   2                  REN = 1;    //å‘é€å®Œæˆåï¼Œç«‹åˆ»å°†æ¥å—ç­‰å¾…æ ‡å¿—ç½®1ï¼Œç­‰å¾…æ¥å—
 307   2                  delay(65535);
 308   2                  delay(65535);
 309   2                  break;
 310   2              case ACTION_SEARCH:
 311   2                  sendCmdAndParams[0] = 0x04;
 312   2                  sendCmdAndParams[1] = 0x01;
 313   2                  sendCmdAndParams[2] = 0x00;
 314   2                  sendCmdAndParams[3] = 0x00;
 315   2                  sendCmdAndParams[4] = 0x03;
 316   2                  sendCmdAndParams[5] = 0xE7;
 317   2                  buildSendCmd(6);
 318   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 319   2                  REN = 1;    //å‘é€å®Œæˆåï¼Œç«‹åˆ»å°†æ¥å—ç­‰å¾…æ ‡å¿—ç½®1ï¼Œç­‰å¾…æ¥å—
 320   2                  delay(65535);
 321   2                  delay(65535);
 322   2                  break;
 323   2              case ACTION_GET_FINGURE_ADDRESS_LIST0:
 324   2                  sendCmdAndParams[0] = 0x1F;
 325   2                  sendCmdAndParams[1] = 0x00;
 326   2                  buildSendCmd(2);
 327   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 328   2                  REN = 1;            
 329   2                  break;
 330   2              case ACTION_GET_FINGURE_ADDRESS_LIST1:
 331   2                  sendCmdAndParams[0] = 0x1F;
 332   2                  sendCmdAndParams[1] = 0x01;
 333   2                  buildSendCmd(2);
 334   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 335   2                  REN = 1;
 336   2                  break;
 337   2              case ACTION_GET_FINGURE_ADDRESS_LIST2:
 338   2                  sendCmdAndParams[0] = 0x1F;
 339   2                  sendCmdAndParams[1] = 0x02;
 340   2                  buildSendCmd(2);
 341   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 342   2                  REN = 1;
 343   2                  break;
 344   2              case ACTION_GET_FINGURE_ADDRESS_LIST3:
 345   2                  sendCmdAndParams[0] = 0x1F;
 346   2                  sendCmdAndParams[1] = 0x03;
 347   2                  buildSendCmd(2);
 348   2                  uartSendBuffer(sendBuffer, sendBufferLength);
 349   2                  REN = 1;
 350   2                  break;
 351   2          }
 352   1      }
 353          
 354          /* ç­‰å¾…ä¸‹ä½æœºåé¦ˆçš„å»¶æ—¶è®¡æ•°å‡½æ•° */
 355          void waitForReceiveFunction(){
 356   1          waitTimes++;
 357   1          delay(500);
 358   1      }
 359          
C51 COMPILER V9.52.0.0   FINGURE                                                           03/09/2017 18:05:58 PAGE 7   

 360          /* å¯¹æŒ‡çº¹æ¨¡å—çš„å¤ä½å‡½æ•° */
 361          void resetFingureFunction(){
 362   1          waitTimes = 0;
 363   1      
 364   1          //@TODO:æ§åˆ¶å¼•è„šè®©æŒ‡çº¹ä¸‹ä½æœºå¤ä½
 365   1      
 366   1          delay(65535);
 367   1          delay(65535);
 368   1          delay(65535);
 369   1          delay(65535);
 370   1      
 371   1          initMain();
 372   1      }
 373          
 374          /**
 375           * è·å–æŒ‡çº¹æ¨¡å—çš„æœ‰æ•ˆæŒ‡çº¹åˆ—è¡¨
 376           * @return [0:æˆåŠŸ,1:è¶…æ—¶å¤±è´¥,2:åé¦ˆé”™è¯¯]
 377           */
 378          uchar getAddressListFunction(){
 379   1          sendCmdStatus = ACTION_GET_FINGURE_ADDRESS_LIST0;
 380   1      
 381   1          for(ut1 = 0; ut1 < 4; ut1++){
 382   2              sendCmdFunction();
 383   2              
 384   2              if(waitForReceive)
 385   2                  delay(65535);
 386   2              if(waitForReceive)
 387   2                  delay(65535);
 388   2              if(waitForReceive)
 389   2                  delay(65535);
 390   2              if(waitForReceive)
 391   2                  delay(65535);
 392   2              //ç­‰å¾…4 * 65535ä¸ªæœºå™¨æ­¥éª¤ï¼Œå¦‚æœä¾ç„¶æ²¡æœ‰åé¦ˆåˆ™å¤±è´¥
 393   2      
 394   2              if(waitForReceive)
 395   2                  return 1;
 396   2              if(cfmCode || receivePackageLength != 35)
 397   2                  return 2;
 398   2      
 399   2              //ä»ä¸²å£åé¦ˆå‚æ•°ä¸­æå–åˆ—è¡¨ç´¢å¼•æ•°æ®
 400   2              for(uintTemp = 1; uintTemp < 33; uintTemp++){
 401   3                  fingureAddressIndex[ut1 * 32 + uintTemp - 1] = receiveParams[uintTemp];
 402   3              }
 403   2              sendCmdStatus++;    //å°†æŒ‡ä»¤ç§»åˆ°ä¸‹ä¸€é¡µ
 404   2          }
 405   1      
 406   1          return 0;
 407   1      }
 408          
 409          /* @TODO:äº¤äº’åé¦ˆ */
 410          void showWarning(){
 411   1      
 412   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1102    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =    128    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     46       7
   IDATA SIZE       =     76    ----
C51 COMPILER V9.52.0.0   FINGURE                                                           03/09/2017 18:05:58 PAGE 8   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
